# 가상 DOM

#### 가상 DOM이란

HTML문서를 자바스크립트 객체로 모델링한 것이다.

#### 가상 DOM을 먼저 업데이트하는 이유

실제 DOM의 업데이트가 다소 느리고 비용이 많이 들 수 있기 때문이다.

#### 실제 DOM

웹 브라우저는 HTML 페이지를 읽어 들이고 나면, 구문을 분석해 노드와 객체의 트리, 즉 DOM (객체 모델)로 변환한다. DOM은 커다란 자바스크립트 객체이다.

#### 실제 DOM의 문제점

- 성능

  - 엘리먼트의 추가나 제거, 엘리먼트의 텍스트나 속성 업데이트 등으로 DOM을 변경할 때마다 브라우저는 레이아웃을 다시 계산하고 페이지의 영향을 받는 부분을 다시 그린다. (=리플로우 발생)
  - getBoundingClientRect()는 한번의 호출로 여러 레이아웃 속성을 검색해 리플로우의 발생 횟수를 줄여줄 수 있다. 읽기/쓰기 작업을 종류별로 나눠 일괄 처리하면 레이아웃 스래싱 현상이 최소화 된다.
    - offsetWidth 같은 레이아웃 속성에 접근할 때 발생하는 리플로우의 횟수를 줄여 성능향상을 시킬수 있다. 그러나 대기중인 레이아웃 변경 사항이 있을 때는 getBoundingClientRect()도 리플로우를 일으킬 수 있다.
  - offsetWidth 같은 레이아웃 의존 속성을 읽을 때는 예기치 않은 성능 문제가 생길 수 있으므로 주의해야 한다. 이러한 속성의 값을 여러번 읽어야 하는 경우에는 변수에 값을 캐싱해서 불필요한 레이아웃 재계산을 피할수도 있다. 브라우저가 레이아웃 계산을 이미 수행한 경우라면 requestAnimationFrame API를 사용해 다음 애니메이션 프레임까지 속성 읽기를 미룰 수 있다.

- 브라우저 간 호환성
  - 특정 DOM 엘리먼트와 속성을 지원하지 않는 브라우저가 있을 수도 있다.
    - React의 합성 이벤트 시스템(Synthetic Event System)이 이러한 문제를 해결하고자 했다.
  - SyntheticEvent는 브라우저의 기본 이벤트를 둘러싼 래퍼 객체로, 여러 브라우저에서 일관성을 보장하기 위해 설계되었다.
    - 메커니즘
      - 통합 인터페이스
        - 이벤트 속성에 접근하는 방법이 브라우저마다 달랐다. event.target 혹은 event.srcElement 등을 추상화해 이벤트와 상호 작용하는 일관된 방법을 제공하여 개발자가 특정 브라우저에 맞춘 개별코드 작성작업을 줄여줬다.
      - 이벤트 위임
        - 리액트는 이벤트 리스너를 엘리먼트에 직접 추가하지 않고 대신 루트에서 이벤트를 받는다. 이러한 접근방식은 구형 브라우저의 특정 엘리먼트에서 일부 이벤트를 사용할 수 없는 문제를 방지한다.
      - 다양한 기능 개선
        - 일부 브라우저에서 onChange 이벤트는 값이 변경되는 즉지 발생하지 않고 입력이 포커스를 읽은 경우에만 발생한다. 이러한 입력 엘리먼트 전체에서 onChange 이벤트의 동작을 정규화 했다. 리액트에서는 키를 입력할때마다 발생해 실시간으로 피드백을 제공한다.
      - 네이티브 이벤트 접근
        - 웹 브라우저에서 네이티브 이벤트가 필요한 경우 event.nativeEvent를 통해 접근할수 있다.

#### 문서 조각

- DOM 노드를 저장하는 가벼운 컨테이너
  - DOM이 업데이트 될때마다 브라우저는 레이아웃 재계산, UI 리페인팅, 화면업데이트 등을 수행하므로 속도가 느려질 수 있다. 이때 문서조각의 역활이 중요하다.

```tsx
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  const li = document.createElement("li");
  li.textContent = `목록 항목 ${i + 1}`;
  fragment.appendChild(li);
}
document.getElementById("myList").appendChild(fragment);
```

100개의 목록을 먼저 문서 조각에 추가한다. 그 후에 문서 조각을 기존 목록에 추가한다. 덕분에 문서의 실제 DOM은 각각 100번이 아니라 단 한번 업데이트 된다.

- 리액트의 가상DOM은 문서 조각 개념을 더 나은 방식으로 구현한 것으로 볼 수 있다.
  - 효율적인 비교 알고리즘
    - 변경 사항이 적용되고 현재 가상 DOM과 실제 DOM의 차이점을 확인한다.
  - 단일 렌더링
    - 차이점이 식별되면 리액트는 단 한번의 일괄 처리를 통해 실제 DOM을 업데이트 한다. 문서조각과 비슷한 동작이며 이를 통해 비용이 많이 드는 리플로우와 리페인팅을 최소화한다.

#### 가상 DOM 작동 방식

- 가상 DOM은 실제 DOM의 문제점을 완화하는 유용한 기술이다. 메모리에 DOM의 가상 표현을 만들고 나면, 문서 조각이 그랬듯이 실제 DOM을 직접 수정하지 않고도 가상 표현을 변경할 수 있다.

##### 리액트 엘리먼트

- `React.createElement` 함수를 사용해 생성 되며 엘리먼트를 중첩해 복잡한 사용자 인터페이스를 만들 수 있다.

```tsx
const element = React.createElement(
  "div",
  { className: "my-class" },
  "Hello World!"
);
```

```ts
// console.log(element)

{
    $$typeof: Symbol(react.element),
    type: "div",
    key: null,
    ref: null,
    props: {
        className: "my-class",
        children: "Hello, world!",
    },
    _owner: null,
    _store: {}
}
```

- $$typeof: 객체가 유효한 리액트 엘리먼트인지 확인할 때 사용하는 특수한 심벌이다. 리액트 엘리먼트의 종류를 식별하는 표시자 역활을 한다.
- type: 엘리먼트가 나타내는 컴포넌트의 종류를 알려준다.
- ref: 부모 컴포넌트는 이 속성을 사용해 기본 DOM 노드에 대한 참조를 요청할수 있다.
- props: 컴포넌트에 전달된 모든 속성과 프롭을 포함하는 객체이다.
- \_owner: 프로덕션 빌드가 아닐 때만 접근할 수 있는 속성이다.

```tsx
function Parent() {
  return <Child />;
}

function Child() {
  const element = <div>Hello, World!</div>;
  console.log(element._owner); // Parent
  return element;
}
```

    - Child컴포넌트의 _owner는 Parent컴포넌트로 생성된다. 리액트는 이 정보를 사용해 프롭이나 상태가 변경될 때 엘리먼트의 업데이트를 담당할 컴포넌트를 결정한다. Parent 컴포넌트가 상태를 업데이트하거나 새로운 프롭을 받으면 리액트는 CHild 컴포넌트 그리고 이와 연관된 엘리먼트를 업데이트한다.
    - _owner 속성은 리액트가 내부적으로 구현을 위해서만 사용하는 값이므로, 애플리케이션 코드에 사용하면 안된다.

- \_store: 엘리먼트에 대한 추가 데이터를 저장하기 위해 리액트가 내부적으로 사용하는 객체이다. 내부 구현 세부사항이므로 애플리케이션 코드에서 직접 접근해서는 안된다.

#### 가상 DOM과 실제 DOM 비교

- React.createElement 함수와 DOM에 내장된 document.createElement 메소드는 모두 새로운 엘리먼트를 생성한다는 점에서 유사하지만 React.createElement는 리액트 엘리먼트를 생성하고 document.createElement는 DOM노드를 생성한다. 구현방식은 다르지만 개념적으로 비슷하다.
- React.createElement는 새로운 가상 엘리먼트를 생성하는 함수
- document.createElement는 document.appendChild 등의 API로 DOM에 추가되기 전, 메모리에 새로운 엘리먼트를 생성하는 메소드이다.

```tsx
const divElement = React.createElement(
  "div",
  { className: "my-class" },
  "Hello, World!"
);

const divElement = document.createElement("div");
divElement.className = "my-class";
divElement.textContent = "Hello, World!";
```
- 리액트의 가상 DOM은 트리 같은 엘리먼트 구조를 표현한다는 점에서 실제 DOM과 개념이 유사하다.
- 리액트 컴포넌트가 렌더링되면 리액트는 새 가상 DOM 트리를 생성하고 이전 가상 DOM 트리와 비교한 다음, 이전 트리를 새 트리와 일치하도록 업데이트하는 데 필요한 최소 변경 횟수를 계산한다. 이를 재조정 프로세스(reconcilation process)라고 한다.

##### 효율적인 업데이트
- 리액트 컴포넌트의 상태나 프롭이 변경되면 리액트는 업데이트된 사용자 인터페이스를 표현하는 새로운 리액트 엘리먼트 트리를 생성한다.
- 새 트리와 이전 트리를 노드별로 비교해 트리의 어느 부분이 변경되었는지 알아내는 작업을 디핑(Diffing)이라한다. 이때 디핑 알고리즘을 사용한다.
- 디핑 알고리즘
    - 두 트리의 루트에 있는 노드가 다른경우, 리액트는 기존 트리 전체를 새 트리로 대체한다.
    - 루트 노드가 동일하다면 리액트는 노드의 속성이 변경된 경우에만 업데이트 한다.
    - 자식 노드가 다른 경우 리액트는 변경된 자식 노드만 업데이트한다. 리액트는 하위 트리전체를 다시 생성하지 않고 변경된 노드만 업데이트한다.
    - 노드의 자식들이 동일하지만 순서가 변경된 경우, 리액트는 노드를 다시 생성하지 않고 실제 DOM에서 노드의순서를 다시 설정한다.
    - 트리에서 노드가 제거되면 리액트는 실제 DOM에서 노드를 제거한다.
    - 트리에 새 노드가 추가되면 리액트는 해당 노드를 실제 DOM에 추가한다.
    - 노드의 종류가 변경된 경우(예: div에서 span으로 변경) 리액트는 이전 노드를 제거하고 변경된 종류의 새 노드를 생성한다.
    - 노드에 key 프롭이 있다면 리액트는 이를 사용해 노드의 교체가 필요한지 파악한다. 컴포넌트 상태를 재설정할 때 유용하다.

##### 불필요한 리렌더링
- 리렌더링은 애초에 리액트가 설계된 대로 작동하는 방식이다.
- 리렌더링은 리액트가 각 함수 컴포넌트를 재귀적으로 호출하면서 프롭을 인수로 각 함수 컴포넌트에 전달한다는 의미이다.
- 리액트는 프롭이 변경되지 않은 컴포넌트도 무시하지 않고 상태나 프롭이 변경된 부모 컴포넌트의 모든 자식 컴포넌트를 호출한다. 리액트는 컴포넌트가 어느 상태에 종속되는지 알지 못하기 때문에 UI의 일관성을 유지하기 위해 모든 컴포넌트를 리렌더링한다.
